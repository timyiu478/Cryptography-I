{"$message_type":"diagnostic","message":"consider removing unnecessary double parentheses","code":{"code":"clippy::double_parens","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1593,"byte_end":1604,"line_start":50,"line_end":50,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"        let cipher = Aes128::new((&self.key));","highlight_start":34,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#double_parens","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(clippy::double_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: consider removing unnecessary double parentheses\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:50:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let cipher = Aes128::new((&self.key));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#double_parens\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(clippy::double_parens)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around function argument","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1593,"byte_end":1594,"line_start":50,"line_end":50,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        let cipher = Aes128::new((&self.key));","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1603,"byte_end":1604,"line_start":50,"line_end":50,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        let cipher = Aes128::new((&self.key));","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1593,"byte_end":1594,"line_start":50,"line_end":50,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"        let cipher = Aes128::new((&self.key));","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1603,"byte_end":1604,"line_start":50,"line_end":50,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"        let cipher = Aes128::new((&self.key));","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary parentheses around function argument\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:50:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let cipher = Aes128::new((&self.key));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_parens)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let cipher = Aes128::new(\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0m&self.key\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let cipher = Aes128::new(&self.key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `inBlock` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1693,"byte_end":1700,"line_start":52,"line_end":52,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"        let mut inBlock: GenericArray<u8, U16> = GenericArray::default();","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_assignments)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: value assigned to `inBlock` is never read\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:52:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut inBlock: GenericArray<u8, U16> = GenericArray::default();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: maybe it is overwritten before being read?\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_assignments)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `ciphertext`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2770,"byte_end":2780,"line_start":84,"line_end":84,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"    fn decrypt(&self, ciphertext: &[u8]) -> Vec<u8> {","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2770,"byte_end":2780,"line_start":84,"line_end":84,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"    fn decrypt(&self, ciphertext: &[u8]) -> Vec<u8> {","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"_ciphertext","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `ciphertext`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:84:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn decrypt(&self, ciphertext: &[u8]) -> Vec<u8> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_ciphertext`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"method `pkcs5Padding` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":629,"byte_end":641,"line_start":25,"line_end":25,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"    fn pkcs5Padding(plaintext: &[u8]) -> Vec<u8> {","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(non_snake_case)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":629,"byte_end":641,"line_start":25,"line_end":25,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"    fn pkcs5Padding(plaintext: &[u8]) -> Vec<u8> {","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":"pkcs5_padding","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: method `pkcs5Padding` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:25:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn pkcs5Padding(plaintext: &[u8]) -> Vec<u8> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `pkcs5_padding`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(non_snake_case)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `blockSize` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":685,"byte_end":694,"line_start":26,"line_end":26,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let blockSize = 16;","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":685,"byte_end":694,"line_start":26,"line_end":26,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let blockSize = 16;","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":"block_size","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `blockSize` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:26:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let blockSize = 16;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `block_size`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `plaintextWithPadding` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":717,"byte_end":737,"line_start":27,"line_end":27,"column_start":17,"column_end":37,"is_primary":true,"text":[{"text":"        let mut plaintextWithPadding: Vec<u8> = plaintext.to_vec();","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":717,"byte_end":737,"line_start":27,"line_end":27,"column_start":17,"column_end":37,"is_primary":true,"text":[{"text":"        let mut plaintextWithPadding: Vec<u8> = plaintext.to_vec();","highlight_start":17,"highlight_end":37}],"label":null,"suggested_replacement":"plaintext_with_padding","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `plaintextWithPadding` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:27:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut plaintextWithPadding: Vec<u8> = plaintext.to_vec();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `plaintext_with_padding`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `paddingLength` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":781,"byte_end":794,"line_start":28,"line_end":28,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"        let paddingLength = blockSize - (plaintext.len() % blockSize); ","highlight_start":13,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":781,"byte_end":794,"line_start":28,"line_end":28,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"        let paddingLength = blockSize - (plaintext.len() % blockSize); ","highlight_start":13,"highlight_end":26}],"label":null,"suggested_replacement":"padding_length","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `paddingLength` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:28:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let paddingLength = blockSize - (plaintext.len() % blockSize); \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `padding_length`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `plaintextWithPadding` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1494,"byte_end":1514,"line_start":48,"line_end":48,"column_start":13,"column_end":33,"is_primary":true,"text":[{"text":"        let plaintextWithPadding = Aes128CbcCipher::pkcs5Padding(plaintext);","highlight_start":13,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1494,"byte_end":1514,"line_start":48,"line_end":48,"column_start":13,"column_end":33,"is_primary":true,"text":[{"text":"        let plaintextWithPadding = Aes128CbcCipher::pkcs5Padding(plaintext);","highlight_start":13,"highlight_end":33}],"label":null,"suggested_replacement":"plaintext_with_padding","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `plaintextWithPadding` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:48:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let plaintextWithPadding = Aes128CbcCipher::pkcs5Padding(plaintext);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `plaintext_with_padding`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `cipherBlocks` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1623,"byte_end":1635,"line_start":51,"line_end":51,"column_start":17,"column_end":29,"is_primary":true,"text":[{"text":"        let mut cipherBlocks:Vec<GenericArray<u8, U16>> = Vec::new();","highlight_start":17,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1623,"byte_end":1635,"line_start":51,"line_end":51,"column_start":17,"column_end":29,"is_primary":true,"text":[{"text":"        let mut cipherBlocks:Vec<GenericArray<u8, U16>> = Vec::new();","highlight_start":17,"highlight_end":29}],"label":null,"suggested_replacement":"cipher_blocks","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `cipherBlocks` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:51:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cipherBlocks:Vec<GenericArray<u8, U16>> = Vec::new();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `cipher_blocks`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `inBlock` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1693,"byte_end":1700,"line_start":52,"line_end":52,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"        let mut inBlock: GenericArray<u8, U16> = GenericArray::default();","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1693,"byte_end":1700,"line_start":52,"line_end":52,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"        let mut inBlock: GenericArray<u8, U16> = GenericArray::default();","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":"in_block","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `inBlock` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:52:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut inBlock: GenericArray<u8, U16> = GenericArray::default();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `in_block`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `outBlock` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1767,"byte_end":1775,"line_start":53,"line_end":53,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"        let mut outBlock: GenericArray<u8, U16> = GenericArray::default();","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1767,"byte_end":1775,"line_start":53,"line_end":53,"column_start":17,"column_end":25,"is_primary":true,"text":[{"text":"        let mut outBlock: GenericArray<u8, U16> = GenericArray::default();","highlight_start":17,"highlight_end":25}],"label":null,"suggested_replacement":"out_block","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `outBlock` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:53:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m53\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut outBlock: GenericArray<u8, U16> = GenericArray::default();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `out_block`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `blockVec` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1879,"byte_end":1887,"line_start":57,"line_end":57,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        for (index, blockVec) in plaintextWithPadding.chunks(16).enumerate() {","highlight_start":21,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":1879,"byte_end":1887,"line_start":57,"line_end":57,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        for (index, blockVec) in plaintextWithPadding.chunks(16).enumerate() {","highlight_start":21,"highlight_end":29}],"label":null,"suggested_replacement":"block_vec","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `blockVec` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:57:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for (index, blockVec) in plaintextWithPadding.chunks(16).enumerate() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `block_vec`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `encyptedIV` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2080,"byte_end":2090,"line_start":61,"line_end":61,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"                let mut encyptedIV = iv;","highlight_start":25,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2080,"byte_end":2090,"line_start":61,"line_end":61,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"                let mut encyptedIV = iv;","highlight_start":25,"highlight_end":35}],"label":null,"suggested_replacement":"encypted_iv","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `encyptedIV` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:61:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let mut encyptedIV = iv;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `encypted_iv`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `previousBlock` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2276,"byte_end":2289,"line_start":66,"line_end":66,"column_start":21,"column_end":34,"is_primary":true,"text":[{"text":"                let previousBlock = cipherBlocks.last().expect(\"No previous block\");","highlight_start":21,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2276,"byte_end":2289,"line_start":66,"line_end":66,"column_start":21,"column_end":34,"is_primary":true,"text":[{"text":"                let previousBlock = cipherBlocks.last().expect(\"No previous block\");","highlight_start":21,"highlight_end":34}],"label":null,"suggested_replacement":"previous_block","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `previousBlock` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:66:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let previousBlock = cipherBlocks.last().expect(\"No previous block\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `previous_block`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `cipherBlock` should have a snake case name","code":{"code":"non_snake_case","explanation":null},"level":"warning","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2621,"byte_end":2632,"line_start":77,"line_end":77,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"        for cipherBlock in cipherBlocks {","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"convert the identifier to snake case","code":null,"level":"help","spans":[{"file_name":"block_ciphers/src/aes128cbccipher.rs","byte_start":2621,"byte_end":2632,"line_start":77,"line_end":77,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"        for cipherBlock in cipherBlocks {","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":"cipher_block","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable `cipherBlock` should have a snake case name\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mblock_ciphers/src/aes128cbccipher.rs:77:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for cipherBlock in cipherBlocks {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: convert the identifier to snake case: `cipher_block`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"16 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 16 warnings emitted\u001b[0m\n\n"}
